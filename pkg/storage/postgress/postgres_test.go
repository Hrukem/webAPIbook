package postgress

import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
	"github.com/ory/dockertest/v3"
	"github.com/ory/dockertest/v3/docker"
	"golang_ninja/webAPIbook/pkg/config"
	"log"
	"os"
	"reflect"
	"strings"
	"testing"
	"time"
)

var (
	db     *sql.DB
	dbTest *DB
	s      S
)

func prepareTestDb(hostAndPort string) {
	portDb := strings.Replace(hostAndPort, "localhost:", "", 1)
	config.Cfg.Dbhost = "localhost"
	config.Cfg.Dbport = portDb
	config.Cfg.Dbuser = "user_name"
	config.Cfg.Dbpass = "secret"
	config.Cfg.Dbname = "webapibooks"

	connDbTest, err := ConnDbPostgres()
	if err != nil {
		log.Fatal("error create PostgresDb in postgres_test")
	}

	dbTest = connDbTest
	_, err = dbTest.Exec("create table books (id integer primary key generated by default as identity, title varchar(255) not null, author varchar (255) not null, publishing varchar (255) not null, dateInsert timestamp (0) without time zone);")
	if err != nil {
		log.Println("error create table:\n ", err)
	}
}

func TestMain(m *testing.M) {
	// uses a sensible default on windows (tcp/http) and linux/osx (socket)
	pool, err := dockertest.NewPool("")
	if err != nil {
		log.Fatalf("Could not connect to docker: %s", err)
	}

	// pulls an image, creates a container based on it and runs it
	resource, err := pool.RunWithOptions(&dockertest.RunOptions{
		Repository: "postgres",
		Tag:        "11",
		Env: []string{
			"POSTGRES_PASSWORD=secret",
			"POSTGRES_USER=user_name",
			"POSTGRES_DB=dbname",
			"listen_addresses = '*'",
		},
	}, func(config *docker.HostConfig) {
		// set AutoRemove to true so that stopped container goes away by itself
		config.AutoRemove = true
		config.RestartPolicy = docker.RestartPolicy{Name: "no"}
	})
	if err != nil {
		log.Fatalf("Could not start resource: %s", err)
	}

	hostAndPort := resource.GetHostPort("5432/tcp")

	databaseUrl := fmt.Sprintf("postgres://user_name:secret@%s/dbname?sslmode=disable", hostAndPort)

	log.Println("Connecting to database on url: ", databaseUrl)

	err = resource.Expire(120) // Tell docker to hard kill the container in 120 seconds
	if err != nil {
		log.Println("error Expire in postgres_test", err)
	}

	// exponential backoff-retry, because the application in the container might not be ready to accept connections yet
	pool.MaxWait = 120 * time.Second
	if err = pool.Retry(func() error {
		db, err = sql.Open("postgres", databaseUrl)
		if err != nil {
			return err
		}
		return db.Ping()
	}); err != nil {
		log.Fatalf("Could not connect to docker: %s", err)
	}

	_, err = db.Exec("create database webapibooks;")
	if err != nil {
		log.Println("error create database:\n", err)
	}

	prepareTestDb(hostAndPort)

	code := m.Run()

	// You can't defer this because os.Exit doesn't care for defer
	if err = pool.Purge(resource); err != nil {
		log.Fatalf("Could not purge resource: %s", err)
	}

	os.Exit(code)
}

func TestS_Insert(t *testing.T) {
	b := Book{"newT", "Roman", "Very gook pub"}
	b1 := Book{"new2", "Roman2", "Very gook pub2"}

	_, err := s.Insert(b, dbTest)
	if err != nil {
		log.Println("error insert in TestS_Insert in postgres_test:\n", err)
	}

	_, err = s.Insert(b1, dbTest)
	if err != nil {
		log.Println("error insert in TestS_Insert in postgres_test:\n", err)
	}

	var bTest Book
	row := dbTest.QueryRow("select title, author, publishing from books where id=$1", 1)
	err = row.Scan(&bTest.Title, &bTest.Author, &bTest.Publishing)
	if err != nil {
		log.Println("error Scan book in TestS_Insert in postgres_test:\n", err)
	}
	if bTest != b {
		t.Errorf("error insert in db Postgres, expected %v, got %v", b, bTest)
	}

	row = dbTest.QueryRow("select title, author, publishing from books where id=$1", 2)
	err = row.Scan(&bTest.Title, &bTest.Author, &bTest.Publishing)
	if err != nil {
		log.Println("error Scan book in TestS_Insert in postgres_test:\n", err)
	}
	if bTest != b1 {
		t.Errorf("error insert in db Postgres, expected %v, got %v", b, bTest)
	}
}

func TestS_SelectAll(t *testing.T) {
	bTest := books{1, "newT", "Roman", "Very gook pub"}
	b1Test := books{2, "new2", "Roman2", "Very gook pub2"}
	booksTest := []books{bTest, b1Test}

	booksAll, err := s.SelectAll(dbTest)
	if err != nil {
		log.Println("error select in TestS_SelectAll() in postgres_test:\n", err)
	}

	if !reflect.DeepEqual(booksTest, booksAll) {
		t.Errorf("error select all from db Postgres, expected %v, got %v", booksTest, booksAll)
	}
}
